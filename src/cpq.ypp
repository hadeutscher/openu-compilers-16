%skeleton "lalr1.cc"
%require  "3.0"
%{
#include <iostream>

#include "cpq.h"
#include "environment.h"
#include "lexer.h"

%}
%language "c++"
%defines
%define api.namespace {cpq}
%define parser_class_name {Parser}
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.trace
%define parse.error verbose
%locations

%code requires {
    namespace cpq { class Lexer; class Driver; }
}
%parse-param { cpq::Lexer& lexer }
%parse-param { cpq::Driver& driver }

%code {
    #undef yylex
    #define yylex lexer.next_token
}

%token BREAK CASE DEFAULT ELSE FLOAT IF INPUT INT OUTPUT STATIC_CAST SWITCH WHILE
%token LPAREN RPAREN LCURL RCURL COMMA COLON SEMICOLON ASSIGN
%token OP_EQ OP_NE OP_LT OP_GT OP_GEQ OP_LEQ OP_ADD OP_SUB OP_MUL OP_DIV OP_OR OP_AND OP_NOT
%token END

%token <int> NUM_INT
%token <float> NUM_FLOAT
%token <std::string> ID

%%
%start program;
program : declarations stmt_block ;

declarations : declarations declaration
             | %empty;

declaration : idlist COLON type SEMICOLON ;

type : INT
     | FLOAT
	 ;

idlist : idlist COMMA ID
       | ID
	   ;

stmt : assignment_stmt
      | input_stmt
      | output_stmt
      | cast_stmt
      | if_stmt
      | while_stmt
      | switch_stmt
      | break_stmt
      | stmt_block
	  ;

assignment_stmt : ID ASSIGN expression SEMICOLON ;

input_stmt : INPUT LPAREN ID RPAREN SEMICOLON ;
output_stmt : OUTPUT LPAREN expression RPAREN SEMICOLON ;

cast_stmt : ID ASSIGN STATIC_CAST LPAREN type RPAREN  LPAREN expression RPAREN SEMICOLON ;

if_stmt : IF LPAREN boolexpr RPAREN stmt ELSE stmt ;

while_stmt : WHILE LPAREN boolexpr RPAREN stmt ;

switch_stmt : SWITCH LPAREN expression RPAREN LCURL caselist
                           DEFAULT COLON stmtlist RCURL ;
caselist : caselist CASE num COLON stmtlist
         | %empty;

break_stmt : BREAK SEMICOLON ;

stmt_block : LCURL stmtlist RCURL ;

stmtlist  : stmtlist stmt
          | %empty;

boolexpr : boolexpr OP_OR boolterm
         | boolterm
		 ;

boolterm : boolterm OP_AND boolfactor
         | boolfactor
		 ;

boolfactor : OP_NOT LPAREN boolexpr RPAREN
           | expression  OP_EQ  expression
           | expression  OP_NE  expression
           | expression  OP_LT  expression
           | expression  OP_GT  expression
           | expression  OP_LEQ  expression
           | expression  OP_GEQ  expression
		   ;

expression : expression OP_ADD term
		   | expression OP_SUB term
           | term
		   ;

term : term OP_MUL factor
	 | term OP_DIV factor
     | factor
	 ;

factor : LPAREN expression RPAREN
       | ID
       | num
	   ;

num : NUM_FLOAT
    | NUM_INT
    ;
%%
void cpq::Parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}