%skeleton "lalr1.cc"
%require  "3.0"
%{
#include <iostream>

#include "sdt_operations.h"
#include "environment.h"
#include "label.h"
#include "driver.h"
#include "variable.h"
#include "lexer.h"

%}
%language "c++"
%defines
%define api.namespace {cpq}
%define parser_class_name {Parser}
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.trace
%define parse.error verbose
%locations

%code requires {
    #include "sdt_types.h"
    namespace cpq { class Lexer; class Driver; }
}
%parse-param { cpq::Lexer& lexer }
%parse-param { cpq::Driver& driver }

%code {
    #undef yylex
    #define yylex lexer.next_token
}

%token BREAK CASE DEFAULT ELSE FLOAT IF INPUT INT OUTPUT STATIC_CAST SWITCH WHILE
%token LPAREN RPAREN LCURL RCURL COMMA COLON SEMICOLON ASSIGN
%token OP_EQ OP_NE OP_LT OP_GT OP_GEQ OP_LEQ OP_ADD OP_SUB OP_MUL OP_DIV OP_OR OP_AND OP_NOT
%token END 0

%token <int> NUM_INT
%token <float> NUM_FLOAT
%token <std::string> ID

%nterm <Type> type
%nterm <std::vector<std::string>> idlist
%nterm <Expression> expression term factor num

%%
%start program;
program : declarations stmt_block ;

declarations : declarations declaration
             | %empty ;

declaration : idlist COLON type SEMICOLON
{
    for (auto id : $1) {
        driver.env().insert(id, $3);
    }
};

type : INT { $$ = Type::Int; }
     | FLOAT { $$ = Type::Float; }
	 ;

idlist : idlist COMMA ID { $$ = $1; $$.push_back($3); }
       | ID { $$.push_back($1); }
	   ;

stmt : assignment_stmt
      | input_stmt
      | output_stmt
      | cast_stmt
      | if_stmt
      | while_stmt
      | switch_stmt
      | break_stmt
      | stmt_block
	  ;

assignment_stmt : ID ASSIGN expression SEMICOLON 
{
    auto dest_type = get_var_type_or_error(driver, lexer, $1);
    if (dest_type != Type::Float && $3.type == Type::Float) {
        throw syntax_error(lexer.loc, "cannot implicitly convert float to int");
    }
    auto src_var = cast_if_needed(driver, $3.var, $3.type, dest_type);
    switch (dest_type) {
        case Type::Int:
            driver.gen("IASN", $1, src_var);
            break;
        case Type::Float:
            driver.gen("RASN", $1, src_var);
            break;
    }
};

input_stmt : INPUT LPAREN ID RPAREN SEMICOLON ;
output_stmt : OUTPUT LPAREN expression RPAREN SEMICOLON ;

cast_stmt : ID ASSIGN STATIC_CAST LPAREN type RPAREN  LPAREN expression RPAREN SEMICOLON ;

if_stmt : IF LPAREN boolexpr RPAREN stmt ELSE stmt ;

while_stmt : WHILE LPAREN boolexpr RPAREN stmt ;

switch_stmt : SWITCH LPAREN expression RPAREN LCURL caselist
                           DEFAULT COLON stmtlist RCURL ;
caselist : caselist CASE num COLON stmtlist
         | %empty ;

break_stmt : BREAK SEMICOLON ;

stmt_block : LCURL stmtlist RCURL ;

stmtlist  : stmtlist stmt
          | %empty ;

boolexpr : boolexpr OP_OR boolterm
         | boolterm
		 ;

boolterm : boolterm OP_AND boolfactor
         | boolfactor
		 ;

boolfactor : OP_NOT LPAREN boolexpr RPAREN
           | expression  OP_EQ  expression
           | expression  OP_NE  expression
           | expression  OP_LT  expression
           | expression  OP_GT  expression
           | expression  OP_LEQ  expression
           | expression  OP_GEQ  expression
		   ;

expression : expression OP_ADD term { $$ = gen_arithmetic_op_expr(driver, "IADD", "RADD", $1, $3); }
		   | expression OP_SUB term { $$ = gen_arithmetic_op_expr(driver, "ISUB", "RSUB", $1, $3); }
           | term { $$ = Expression($1); }
		   ;

term : term OP_MUL factor { $$ = gen_arithmetic_op_expr(driver, "IMUL", "RMUL", $1, $3); }
	 | term OP_DIV factor { $$ = gen_arithmetic_op_expr(driver, "IDIV", "RDIV", $1, $3); }
     | factor { $$ = Expression($1); }
	 ;

factor : LPAREN expression RPAREN { $$ = Expression($2); }
       | ID { $$ = Expression(get_var_type_or_error(driver, lexer, $1), $1); }
       | num { $$ = Expression($1); }
	   ;

num : NUM_FLOAT { $$ = Expression(Type::Float, Variable::make_temp()); driver.gen("RASN", $$.var, $1); }
    | NUM_INT { $$ = Expression(Type::Int, Variable::make_temp()); driver.gen("IASN", $$.var, $1); }
    ;
%%
void cpq::Parser::error (const location_type& l, const std::string& m)
{
  std::cerr << l << ": " << m << std::endl;
}